// Generated by CoffeeScript 2.3.0
var DEBUG, NO_COLOR, NO_WARNINGS, TRACE_WARNINGS, cleanStack, colorize, createLog, createWriter, def, embed, env, getPrefix, hasFlag, inspect, isCLI, isQuiet, isTop, join, log, methods, muted, quiet, undef;

colorize = require('./colorize');

def = Object.defineProperty;

env = typeof process !== 'undefined' ? process.env : window;

isCLI = typeof window === 'undefined';

hasFlag = isCLI ? require('has-flag') : function() {
  return false;
};

isQuiet = hasFlag('--quiet') || env.QUIET === '1';

NO_COLOR = isCLI && process.stdout.isTTY ? hasFlag('--no-color') || env.NO_COLOR === '1' : env.COLOR !== '1';

NO_WARNINGS = hasFlag('--no-warnings') || env.NO_WARNINGS === '1';

TRACE_WARNINGS = !NO_WARNINGS ? hasFlag('--trace-warnings') || env.TRACE_WARNINGS === '1' : false;

undef = function() {}; // no-op

muted = function() {
  return quiet;
};

quiet = function() {}; // no-op

colorize(quiet, !NO_COLOR);

methods = {
  warn: null,
  error: null,
  write: null,
  debug: null,
  prefix: null,
  stylize: null,
  clear: null,
  trace: null
};

createLog = function() {
  var log;
  log = function(...args) {
    return log.write(...args);
  };
  if (!isTop(this)) {
    def(log, '_parent', {
      value: this
    });
  }
  return Object.assign(log, methods);
};

methods.create = createLog;

methods.trace = (function() {
  var home;
  home = null;
  if (isCLI) {
    (function() {
      var mappedChars;
      mappedChars = {
        '.': '\\.',
        '\\': '\\\\'
      };
      home = require('os').homedir() + require('path').sep;
      home = home.replace(/[\.\\]/g, function(ch) {
        return mappedChars[ch];
      });
      return home = new RegExp('\\(' + home, 'g');
    })();
  }
  return function(framesToPop = 0) {
    var stack;
    stack = log.cleanStack(Error().stack.slice(6));
    stack = stack.split('\n').slice(1 + framesToPop).join('\n');
    home && (stack = stack.replace(home, '(~/'));
    return this.gray(stack);
  };
})();

// Vararg string formatter
methods.stylize = function(...args) {
  var arg, i, input, match, offset, output, pattern;
  output = '';
  i = 0;
  if (typeof args[0] === 'string') {
    input = args[i++];
    offset = 0;
    pattern = /%[dfisO]/g;
    while (match = pattern.exec(input)) {
      arg = args[i++];
      output += input.slice(offset, match.index) + embed(arg, match[0]);
      offset = match.index + 2;
    }
    output += input.slice(offset);
  }
  while (i < args.length) {
    arg = args[i++];
    output = join(output, typeof arg === 'string' ? arg : inspect(arg));
  }
  return output;
};

embed = function(arg, type) {
  switch (type) {
    case '%s':
      return String(arg);
    case '%O':
      return inspect(arg);
    case '%d':
    case '%f':
      return Number(arg);
    case '%i':
      return parseInt(arg);
    default:
      return arg;
  }
};

if (isCLI) {
  isTop = function(arg) {
    return arg === global;
  };
  // Format a non-string
  inspect = (function() {
    var opts, util;
    util = require('util');
    opts = {
      colors: !NO_COLOR,
      depth: 1
    };
    return function(arg) {
      return util.inspect(arg, opts);
    };
  })();
  createWriter = function(stream, label) {
    return function(...args) {
      var output, prefix;
      prefix = getPrefix(this, label);
      output = log.stylize(...args);
      if (output = join(prefix, output + '\n')) {
        stream.write(output);
      }
    };
  };
  methods.warn = !NO_WARNINGS ? createWriter(process.stdout, quiet.yellow('warn:')) : undef;
  methods.error = createWriter(process.stderr, quiet.red('error:'));
  if (!isQuiet) {
    methods.write = createWriter(process.stdout);
    methods.clear = function() {
      // print line breaks until the screen is empty
      process.stdout.write('\x33[2J');
      // clear the scroll history
      process.stdout.write('\u001b[H\u001b[2J\u001b[3J');
    };
  }
  if (TRACE_WARNINGS) {
    (function() {
      var warn;
      ({warn} = methods);
      return methods.warn = function() {
        warn(...arguments);
        return this.trace(1);
      };
    })();
  }
} else {
  isTop = function(arg) {
    return arg === window;
  };
  inspect = (function() {
    var toString;
    ({toString} = Object.prototype);
    return function(arg) {
      var ctr, str;
      str = toString.call(arg);
      switch (str.slice(8, -1).toLowerCase()) {
        case 'null':
          return 'null';
        case 'undefined':
          return 'undefined';
        case 'array':
          return JSON.stringify(arg);
        case 'object':
          ctr = arg.constructor;
          if (!ctr || ctr === Object) {
            return JSON.stringify(arg, null, 2);
          } else {
            return str;
          }
          break;
        case 'regexp':
          return arg.toString();
        case 'date':
          return arg.toISOString();
        default:
          return str;
      }
    };
  })();
  createWriter = function(stream, label) {
    if (typeof stream === 'function') {
      stream = {
        write: stream
      };
    }
    return function($1, ...args) {
      var $0;
      if (typeof $1 !== 'string') {
        args.unshift($1);
        $1 = '';
      }
      if ($0 = getPrefix(this, label)) {
        $1 = $0 + ' ' + $1;
      }
      if (this._debugId) {
        $1 = '%c' + this._debugId + '%c ' + $1;
        args.unshift(this._debugStyle, '');
      }
      stream.write($1, ...args);
    };
  };
  methods.warn = !NO_WARNINGS ? createWriter(console.warn) : undef;
  methods.error = createWriter(console.error);
  if (!isQuiet) {
    methods.write = createWriter(console.log);
    methods.clear = console.clear;
  }
}

if (isQuiet || !(DEBUG = env.DEBUG)) {
  methods.debug = function(id) {
    var inst;
    inst = createLog.call(this).prefix(log.coal(id));
    inst.write = undef;
    return inst;
  };
} else if (hasFlag('--debug') || /^(\*|1)$/.test(DEBUG)) {
  methods.debug = function(id) {
    return createLog.call(this).prefix(log.coal(id));
  };
} else {
  (function() {
    DEBUG = DEBUG.replace(/\*/g, '.*').replace(/,/g, '|');
    DEBUG = new RegExp('^(' + DEBUG + ')$');
    return methods.debug = isCLI ? function(id) {
      var inst;
      inst = createLog.call(this).prefix(log.coal(id));
      if (!DEBUG.test(id)) {
        inst.write = undef;
      }
      return inst;
    } : (function() {
      var themes;
      themes = [
        {
          text: '#2923EB',
          bkg: '#E2E1F5' // blue
        },
        {
          text: '#D61160',
          bkg: '#EDDAE2' // red
        },
        {
          text: '#8A8AE5',
          bkg: '#1B1B4C' // dark blue
        },
        {
          text: '#67E591',
          bkg: '#0C4652' // dark green
        }
      ];
      return function(id) {
        var inst, theme;
        inst = createLog.call(this);
        if (!DEBUG.test(id)) {
          inst.write = undef;
        }
        theme = themes[Math.floor(Math.random() * themes.length)];
        def(inst, '_debugId', {
          value: id
        });
        return def(inst, '_debugStyle', {
          value: `color: ${theme.text}; background: ${theme.bkg}; border-radius: 3px; padding: 2px;`
        });
      };
    })();
  })();
}

join = function(a, b) {
  if (!a) {
    return b || '';
  } else if (!b) {
    return a;
  } else {
    return a + ' ' + b;
  }
};

getPrefix = function(self, label) {
  var parent, prefix;
  if (prefix = self._prefix) {
    prefix = prefix();
  }
  if (parent = self._parent) {
    prefix = getPrefix(parent, prefix);
  }
  if (label && prefix) {
    return join(prefix, label);
  } else {
    return label || prefix || '';
  }
};

if (isQuiet) {
  methods.prefix = function() {
    return this;
  };
} else {
  colorize(methods, !NO_COLOR);
  methods.prefix = function(prefix) {
    return def(this, '_prefix', {
      value: typeof prefix === 'function' && prefix || function() {
        return prefix;
      },
      configurable: true
    });
  };
}

// Ensure all expected methods exist.
// Warnings and errors are not disabled by --quiet
Object.assign(quiet, methods);

// Quiet overrides
quiet.write = undef;

quiet.prefix = muted;

quiet.clear = undef;

// Ignore any property mutation.
Object.freeze(quiet);

if (isQuiet) {
  log = function() {}; // no-op
  Object.assign(log, quiet);
} else {
  log = createLog();
}

if (isCLI) {
  try {
    cleanStack = require('clean-stack');
  } catch (error) {}
}

// override this to customize log.trace() output
log.cleanStack = cleanStack || function(stack) {
  return stack;
};

module.exports = log;
