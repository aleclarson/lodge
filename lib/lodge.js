// Generated by CoffeeScript 2.3.0
var DEBUG, NO_COLOR, NO_WARNINGS, TRACE_WARNINGS, colorize, createLog, createWriter, def, env, format, getPrefix, hasFlag, inspect, isCLI, isQuiet, join, log, methods, quiet;

colorize = require('./colorize');

def = Object.defineProperty;

env = typeof process !== 'undefined' ? process.env : window;

isCLI = typeof window === 'undefined';

hasFlag = isCLI ? require('has-flag') : function() {
  return false;
};

isQuiet = hasFlag('--quiet') || env.QUIET === '1';

NO_COLOR = isCLI && process.stdout.isTTY ? hasFlag('--no-color') || env.NO_COLOR === '1' : env.COLOR !== '1';

NO_WARNINGS = hasFlag('--no-warnings') || env.NO_WARNINGS === '1';

TRACE_WARNINGS = !NO_WARNINGS ? hasFlag('--trace-warnings') || env.TRACE_WARNINGS === '1' : false;

quiet = function() {}; // no-op

quiet.write = function() {}; // no-op

colorize(quiet, !NO_COLOR);

methods = {
  warn: null,
  error: null,
  write: null,
  debug: null,
  prefix: null,
  clear: null
};

createLog = function() {
  var log;
  log = function(...args) {
    return log.write(...args);
  };
  return Object.assign(log, methods);
};

if (isCLI) {
  inspect = (function() {
    var opts, util;
    util = require('util');
    opts = {
      colors: !NO_COLOR,
      depth: 1
    };
    return function(arg) {
      return util.inspect(arg, opts);
    };
  })();
  format = function(arg, type) {
    switch (type) {
      case '%s':
        return String(arg);
      case '%O':
        return inspect(arg);
      case '%d':
      case '%f':
        return Number(arg);
      case '%i':
        return parseInt(arg);
      default:
        return arg;
    }
  };
  createWriter = function(stream, label) {
    return function(...args) {
      var arg, i, input, match, offset, output, pattern, prefix;
      i = 0;
      prefix = getPrefix(this, label);
      output = '';
      if (typeof args[0] === 'string') {
        input = args[i++];
        offset = 0;
        pattern = /%[dfisO]/g;
        while (match = pattern.exec(input)) {
          arg = args[i++];
          output += input.slice(offset, match.index) + format(arg, match[0]);
          offset = match.index + 2;
        }
        output += input.slice(offset);
      }
      while (i < args.length) {
        arg = args[i++];
        output = join(output, typeof arg === 'string' ? arg : inspect(arg));
      }
      output && (output = join(prefix, output));
      stream.write(output + '\n');
    };
  };
  methods.warn = !NO_WARNINGS ? createWriter(process.stdout, quiet.yellow('warn:')) : quiet.write;
  methods.error = createWriter(process.stderr, quiet.red('error:'));
  if (!isQuiet) {
    methods.write = createWriter(process.stdout);
    methods.clear = function() {
      // print line breaks until the screen is empty
      process.stdout.write('\x33[2J');
      // clear the scroll history
      process.stdout.write('\u001b[H\u001b[2J\u001b[3J');
    };
  }
  if (TRACE_WARNINGS) {
    (function() {
      var warn;
      ({warn} = methods);
      return methods.warn = function() {
        var err, stack;
        warn(...arguments);
        err = new Error;
        Error.captureStackTrace(err, arguments.callee);
        stack = err.stack;
        console.log(stack.slice(stack.indexOf('\n') + 1));
      };
    })();
  }
} else {
  createWriter = function(write) {
    return function($1, ...args) {
      var $0;
      if (!($0 = getPrefix(this))) {
        write($1, ...args);
        return;
      }
      if (!args.length && $1 === '') {
        write($1);
        return;
      }
      if (typeof $1 !== 'string') {
        write($0, $1, ...args);
        return;
      }
      write($0 + ' ' + $1, ...args);
    };
  };
  methods.warn = !NO_WARNINGS ? createWriter(console.warn) : quiet.write;
  methods.error = createWriter(console.error);
  if (!isQuiet) {
    methods.write = createWriter(console.log);
    methods.clear = console.clear;
  }
}

if (isQuiet || !(DEBUG = env.DEBUG)) {
  methods.debug = function() {
    return quiet;
  };
} else if (hasFlag('--debug') || /^(\*|1)$/.test(DEBUG)) {
  methods.debug = createLog;
} else {
  DEBUG = DEBUG.replace(/\*/g, '.*').replace(/,/g, '|');
  DEBUG = new RegExp('^(' + DEBUG + ')$');
  methods.debug = function(id) {
    return DEBUG.test(id) && createLog() || quiet;
  };
}

join = function(a, b) {
  if (a) {
    return a + ' ' + b;
  } else {
    return b;
  }
};

getPrefix = function(self, label) {
  var prefix;
  prefix = (typeof self._prefix === "function" ? self._prefix() : void 0) || '';
  if (self !== log && log._prefix) {
    prefix = join(log._prefix(), prefix);
  }
  if (label) {
    return join(prefix, label);
  } else {
    return prefix;
  }
};

if (isQuiet) {
  methods.prefix = function() {
    return this;
  };
} else {
  colorize(methods, !NO_COLOR);
  methods.prefix = function(prefix) {
    return def(this, '_prefix', {
      value: typeof prefix === 'function' && prefix || function() {
        return prefix;
      },
      configurable: true
    });
  };
}

// Warnings and errors are not disabled by --quiet
quiet.warn = methods.warn;

quiet.error = methods.error;

// Ensure all expected methods exist
quiet.debug = methods.debug;

quiet.prefix = methods.prefix;

quiet.clear = quiet.write;

// Ignore any property mutation.
Object.freeze(quiet);

if (isQuiet) {
  log = function() {}; // no-op
  Object.assign(log, quiet);
  log.create = function() {
    return quiet;
  };
} else {
  log = createLog();
  log.create = createLog;
}

module.exports = log;
